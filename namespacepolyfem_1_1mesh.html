<!-- HTML header for doxygen 1.9.2-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PolyFEM: polyfem::mesh Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript">
    DoxygenAwesomeDarkModeToggle.init()
</script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
</script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeParagraphLink.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PolyFEM
   </div>
  </td>
 </tr>
   <!--BEGIN FULL_SIDEBAR-->
   <tr><td colspan="2">        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td></tr>
   <!--END FULL_SIDEBAR-->
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacepolyfem_1_1mesh.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">polyfem::mesh Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacepolyfem_1_1mesh_1_1_mesh_processing3_d"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh_1_1_mesh_processing3_d.html">MeshProcessing3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepolyfem_1_1mesh_1_1_navigation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh_1_1_navigation.html">Navigation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepolyfem_1_1mesh_1_1_navigation3_d"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh_1_1_navigation3_d.html">Navigation3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacepolyfem_1_1mesh_1_1_polygons"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh_1_1_polygons.html">Polygons</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_c_mesh2_d.html">CMesh2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_c_mesh3_d.html">CMesh3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpolyfem_1_1mesh_1_1_edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpolyfem_1_1mesh_1_1_element.html">Element</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpolyfem_1_1mesh_1_1_face.html">Face</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_local_boundary.html">LocalBoundary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_mesh.html">Mesh</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_mesh2_d.html">Mesh2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_mesh3_d.html">Mesh3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpolyfem_1_1mesh_1_1_mesh3_d_storage.html">Mesh3DStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpolyfem_1_1mesh_1_1_mesh___quality.html">Mesh_Quality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_mesh_nodes.html">MeshNodes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_n_c_mesh2_d.html">NCMesh2D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_n_c_mesh3_d.html">NCMesh3D</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_obstacle.html">Obstacle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpolyfem_1_1mesh_1_1_vertex.html">Vertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpolyfem_1_1mesh_1_1_v_t_u_writer.html">VTUWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab40b3d90650fc21517c5a9af3e4cf960"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(const Eigen::MatrixXd &amp;, Eigen::MatrixXd &amp;, int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ab40b3d90650fc21517c5a9af3e4cf960">EvalParametersFunc</a></td></tr>
<tr class="separator:ab40b3d90650fc21517c5a9af3e4cf960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cec2b541da1111313d4f148bfefbff"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; std::tuple&lt; int, int, bool &gt;int, int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a76cec2b541da1111313d4f148bfefbff">GetAdjacentLocalEdge</a></td></tr>
<tr class="separator:a76cec2b541da1111313d4f148bfefbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac25a28c10b676e06e484d9e1f496f826"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ac25a28c10b676e06e484d9e1f496f826">BoundaryType</a> { <br />
&#160;&#160;<a class="el" href="namespacepolyfem_1_1mesh.html#ac25a28c10b676e06e484d9e1f496f826a9f4b55db1c20898d446a35bf7f99e856">BoundaryType::TriLine</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#ac25a28c10b676e06e484d9e1f496f826a8920b2d7b0827790538a324bc47631b4">BoundaryType::QuadLine</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5caab8c4c2cd6e0f11e2fbb894caeaeccef3">Tri</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#ac25a28c10b676e06e484d9e1f496f826ae9017664588010860a92ceb5f8fcb824">BoundaryType::Quad</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepolyfem_1_1mesh.html#ac25a28c10b676e06e484d9e1f496f826a4c0a11247d92f73fb84baa51e37a3263">BoundaryType::Polygon</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#ac25a28c10b676e06e484d9e1f496f826a3d217ee3a015efcd968eff5f36a5f671">BoundaryType::Polyhedron</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#ac25a28c10b676e06e484d9e1f496f826a4bbb8f967da6d1a610596d7257179c2b">BoundaryType::Invalid</a>
<br />
 }</td></tr>
<tr class="separator:ac25a28c10b676e06e484d9e1f496f826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d29c294eac8e3515c8c721ac4879c2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2">ElementType</a> { <br />
&#160;&#160;<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2a02a335cb56996b16f7bece70be215789">ElementType::Simplex</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2ae38cb4ba5fe9ef406de581b29ed85dba">ElementType::RegularInteriorCube</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2a8b0ab3bbc7eff9a7f2cb5c2b55e5eeaf">ElementType::SimpleSingularInteriorCube</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2a5ce89c0d26dcc6af45bfe5002fcd3d64">ElementType::MultiSingularInteriorCube</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2a357bd1c8b060739c8fef502d46aed97f">ElementType::RegularBoundaryCube</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2abaf3184986c79f23f99cfc4faa826fc5">ElementType::SimpleSingularBoundaryCube</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2ac8474f7aab6df7b49f4bd4f2b92acdbb">ElementType::MultiSingularBoundaryCube</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2abc88e6a23d386795b4d2d0039bdd6f65">ElementType::InterfaceCube</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2a08324bb1398b4fd2d5ba3a6a37c3b7af">ElementType::InteriorPolytope</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2a80bef825f0fa4713f4bdc23033e25fe0">ElementType::BoundaryPolytope</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2aec0fc0100c4fc1ce4eea230c3dc10360">ElementType::Undefined</a>
<br />
 }</td></tr>
<tr class="separator:a52d29c294eac8e3515c8c721ac4879c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1786d2b6b9b3bda8c6667456f9b1f5ca"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5ca">MeshType</a> { <br />
&#160;&#160;<a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5caa189920e88906221b0731b92bfb2ebcd7">Tri</a> = 0, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5caab8c4c2cd6e0f11e2fbb894caeaeccef3">Tri</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5caa11b8c9e9feec9bfa3206f5dffb736b9b">Qua</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5caacc5883e092a3e5989ee2a1f05e6b2934">HSur</a>, 
<br />
&#160;&#160;<a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5caa77501a193048c70975005a2a1dfc15d1">Tet</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5caaf232cbd41deb6ed29912b93b70a8aa30">Hyb</a>, 
<a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5caa77b3ac06c59fd2083e1ee4874c433832">Hex</a>
<br />
 }</td></tr>
<tr class="separator:a1786d2b6b9b3bda8c6667456f9b1f5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a23c11289ee171d378f95b975412b00d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a23c11289ee171d378f95b975412b00d2">log_and_throw_error</a> (const std::string &amp;msg)</td></tr>
<tr class="separator:a23c11289ee171d378f95b975412b00d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd912c9c209068769d339932c8b7c79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a0fd912c9c209068769d339932c8b7c79">read_fem_geometry</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;geometry, const std::string &amp;root_path, std::unique_ptr&lt; <a class="el" href="classpolyfem_1_1mesh_1_1_mesh.html">Mesh</a> &gt; &amp;mesh, const std::vector&lt; std::string &gt; &amp;names=std::vector&lt; std::string &gt;(), const std::vector&lt; Eigen::MatrixXd &gt; &amp;vertices=std::vector&lt; Eigen::MatrixXd &gt;(), const std::vector&lt; Eigen::MatrixXi &gt; &amp;cells=std::vector&lt; Eigen::MatrixXi &gt;(), const bool non_conforming=false)</td></tr>
<tr class="memdesc:a0fd912c9c209068769d339932c8b7c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">read FEM meshes from a geometry JSON array (or single)  <a href="namespacepolyfem_1_1mesh.html#a0fd912c9c209068769d339932c8b7c79">More...</a><br /></td></tr>
<tr class="separator:a0fd912c9c209068769d339932c8b7c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc649d2ea30d21c08a016921d553ec90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#adc649d2ea30d21c08a016921d553ec90">read_obstacle_geometry</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;geometry, const std::vector&lt; <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &gt; &amp;displacements, const std::string &amp;root_path, const int dim, <a class="el" href="classpolyfem_1_1mesh_1_1_obstacle.html">Obstacle</a> &amp;obstacle, const std::vector&lt; std::string &gt; &amp;names=std::vector&lt; std::string &gt;(), const std::vector&lt; Eigen::MatrixXd &gt; &amp;vertices=std::vector&lt; Eigen::MatrixXd &gt;(), const std::vector&lt; Eigen::MatrixXi &gt; &amp;cells=std::vector&lt; Eigen::MatrixXi &gt;(), const bool non_conforming=false)</td></tr>
<tr class="memdesc:adc649d2ea30d21c08a016921d553ec90"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a FEM mesh from a geometry JSON  <a href="namespacepolyfem_1_1mesh.html#adc649d2ea30d21c08a016921d553ec90">More...</a><br /></td></tr>
<tr class="separator:adc649d2ea30d21c08a016921d553ec90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab411f13e27498417ffaa63b50e0f3cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ab411f13e27498417ffaa63b50e0f3cbe">read_fem_mesh</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;jmesh, const std::string &amp;root_path, Eigen::MatrixXd &amp;in_vertices, Eigen::MatrixXi &amp;in_cells, std::vector&lt; std::vector&lt; int &gt;&gt; &amp;in_elements, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;in_weights, size_t &amp;num_faces, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">Selection</a> &gt;&gt; &amp;surface_selections, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">Selection</a> &gt;&gt; &amp;volume_selections)</td></tr>
<tr class="separator:ab411f13e27498417ffaa63b50e0f3cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b062ad34fe687b7f1fb23a07e0696d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ad2b062ad34fe687b7f1fb23a07e0696d">read_obstacle_mesh</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;jmesh, const std::string &amp;root_path, Eigen::MatrixXd &amp;vertices, Eigen::VectorXi &amp;codim_vertices, Eigen::MatrixXi &amp;codim_edges, Eigen::MatrixXi &amp;faces)</td></tr>
<tr class="memdesc:ad2b062ad34fe687b7f1fb23a07e0696d"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a obstacle mesh from a geometry JSON  <a href="namespacepolyfem_1_1mesh.html#ad2b062ad34fe687b7f1fb23a07e0696d">More...</a><br /></td></tr>
<tr class="separator:ad2b062ad34fe687b7f1fb23a07e0696d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d084b6f52a0af47a0f7b9d1e11fc33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aa6d084b6f52a0af47a0f7b9d1e11fc33">apply_default_geometry_parameters</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;geometry_in, <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;geometry_out, const std::string &amp;path_prefix=&quot;&quot;)</td></tr>
<tr class="memdesc:aa6d084b6f52a0af47a0f7b9d1e11fc33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill in missing json geometry parameters with the default values.  <a href="namespacepolyfem_1_1mesh.html#aa6d084b6f52a0af47a0f7b9d1e11fc33">More...</a><br /></td></tr>
<tr class="separator:aa6d084b6f52a0af47a0f7b9d1e11fc33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6039e86ea6e80037d8fe94e72181ada2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a6039e86ea6e80037d8fe94e72181ada2">transform_mesh_from_json</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;transform, Eigen::MatrixXd &amp;vertices)</td></tr>
<tr class="memdesc:a6039e86ea6e80037d8fe94e72181ada2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform a mesh inplace using json parameters including scaling, rotation, and translation.  <a href="namespacepolyfem_1_1mesh.html#a6039e86ea6e80037d8fe94e72181ada2">More...</a><br /></td></tr>
<tr class="separator:a6039e86ea6e80037d8fe94e72181ada2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac070fd8ba3c3767665b0cab25e5c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a3ac070fd8ba3c3767665b0cab25e5c84">append_selections</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;new_selections, const <a class="el" href="classpolyfem_1_1utils_1_1_selection.html#a8465d134d77a8f8dfeaffdde17950e54">Selection::BBox</a> &amp;bbox, const size_t &amp;start_element_id, const size_t &amp;end_element_id, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">Selection</a> &gt;&gt; &amp;selections)</td></tr>
<tr class="separator:a3ac070fd8ba3c3767665b0cab25e5c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f16fdc55deedd0a6cf9a4b4903dacf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ae2f16fdc55deedd0a6cf9a4b4903dacf">read_fem_mesh</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;jmesh, const std::string &amp;root_path, Eigen::MatrixXd &amp;vertices, Eigen::MatrixXi &amp;cells, std::vector&lt; std::vector&lt; int &gt;&gt; &amp;elements, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;weights, size_t &amp;num_faces, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">polyfem::utils::Selection</a> &gt;&gt; &amp;surface_selections, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">polyfem::utils::Selection</a> &gt;&gt; &amp;volume_selections)</td></tr>
<tr class="memdesc:ae2f16fdc55deedd0a6cf9a4b4903dacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a FEM mesh from a geometry JSON  <a href="namespacepolyfem_1_1mesh.html#ae2f16fdc55deedd0a6cf9a4b4903dacf">More...</a><br /></td></tr>
<tr class="separator:ae2f16fdc55deedd0a6cf9a4b4903dacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb1327313435ccafb35bb476b034425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#addb1327313435ccafb35bb476b034425">append_selections</a> (const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;new_selections, const <a class="el" href="classpolyfem_1_1utils_1_1_selection.html#a8465d134d77a8f8dfeaffdde17950e54">polyfem::utils::Selection::BBox</a> &amp;bbox, const size_t &amp;start_element_id, const size_t &amp;end_element_id, std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">polyfem::utils::Selection</a> &gt;&gt; &amp;selections)</td></tr>
<tr class="separator:addb1327313435ccafb35bb476b034425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9e86a0cbb90821ce9b4c1f37b8df6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a2c9e86a0cbb90821ce9b4c1f37b8df6c">find</a> (const Eigen::VectorXi &amp;<a class="el" href="_assembler_8cpp.html#a0ceb8b1b1b63245b857fa3d925c17858">vec</a>, int <a class="el" href="_spline_basis3d_8cpp.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>)</td></tr>
<tr class="separator:a2c9e86a0cbb90821ce9b4c1f37b8df6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add37eb917dcfad1ce25e9f2aca7ca9db"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#add37eb917dcfad1ce25e9f2aca7ca9db">line_weight</a> (Eigen::Matrix&lt; double, 2, 2 &gt; &amp;e, Eigen::VectorXd &amp;v)</td></tr>
<tr class="separator:add37eb917dcfad1ce25e9f2aca7ca9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4be3bab49d477dc6c218108b278acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a0d4be3bab49d477dc6c218108b278acc">clip_polygon_by_half_plane</a> (const Eigen::MatrixXd &amp;P, const Eigen::RowVector2d &amp;q1, const Eigen::RowVector2d &amp;q2, Eigen::MatrixXd &amp;result)</td></tr>
<tr class="separator:a0d4be3bab49d477dc6c218108b278acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa907e396724bca7b40434c67f80f2c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aaa907e396724bca7b40434c67f80f2c9">compute_visibility_kernel</a> (const Eigen::MatrixXd &amp;IV, Eigen::MatrixXd &amp;OV)</td></tr>
<tr class="separator:aaa907e396724bca7b40434c67f80f2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e56322029f56281de64523a44a2b18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ae1e56322029f56281de64523a44a2b18">is_star_shaped</a> (const Eigen::MatrixXd &amp;IV, Eigen::RowVector3d &amp;bary)</td></tr>
<tr class="separator:ae1e56322029f56281de64523a44a2b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffb307ad1f47d970021d26cff0653d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a8ffb307ad1f47d970021d26cff0653d7">offset_polygon</a> (const Eigen::MatrixXd &amp;IV, Eigen::MatrixXd &amp;OV, double eps)</td></tr>
<tr class="separator:a8ffb307ad1f47d970021d26cff0653d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0e69679f580e427e1db3922b2a5311"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aee0e69679f580e427e1db3922b2a5311">is_inside</a> (const Eigen::MatrixXd &amp;IV, const Eigen::MatrixXd &amp;Q, std::vector&lt; bool &gt; &amp;inside)</td></tr>
<tr class="separator:aee0e69679f580e427e1db3922b2a5311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b53129ddbb617fbeb6b26d82171fd56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a5b53129ddbb617fbeb6b26d82171fd56">sample_polygon</a> (const Eigen::MatrixXd &amp;IV, int num_samples, Eigen::MatrixXd &amp;S)</td></tr>
<tr class="separator:a5b53129ddbb617fbeb6b26d82171fd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace612043f121e5ebe43de933f553396d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ace612043f121e5ebe43de933f553396d">edge_adjacency_graph</a> (const Eigen::MatrixXi &amp;Q, Eigen::MatrixXi &amp;edge_index, std::vector&lt; std::vector&lt; int &gt;&gt; &amp;adj, std::vector&lt; std::pair&lt; int, int &gt;&gt; *pairs_of_edges=nullptr, std::vector&lt; std::pair&lt; int, int &gt;&gt; *pairs_of_quads=nullptr, Eigen::MatrixXi *quad_index=nullptr)</td></tr>
<tr class="separator:ace612043f121e5ebe43de933f553396d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa343729fa98cb887e320f61247db1843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aa343729fa98cb887e320f61247db1843">instantiate_pattern</a> (const Eigen::MatrixXd &amp;IV, const Eigen::MatrixXi &amp;IF, const Eigen::MatrixXd &amp;PV, const Eigen::MatrixXi &amp;PF, Eigen::MatrixXd &amp;OV, Eigen::MatrixXi &amp;OF, Eigen::VectorXi *SF=nullptr, <a class="el" href="namespacepolyfem_1_1mesh.html#ab40b3d90650fc21517c5a9af3e4cf960">EvalParametersFunc</a> evalFunc=nullptr, <a class="el" href="namespacepolyfem_1_1mesh.html#a76cec2b541da1111313d4f148bfefbff">GetAdjacentLocalEdge</a> getAdjLocalEdge=nullptr)</td></tr>
<tr class="separator:aa343729fa98cb887e320f61247db1843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a98f8d68f49e3a96c2948a812d03521"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a4a98f8d68f49e3a96c2948a812d03521">refine_quad_mesh</a> (const Eigen::MatrixXd &amp;IV, const Eigen::MatrixXi &amp;IF, Eigen::MatrixXd &amp;OV, Eigen::MatrixXi &amp;OF)</td></tr>
<tr class="separator:a4a98f8d68f49e3a96c2948a812d03521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc2511254531ec745f412fc383ba050d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#acc2511254531ec745f412fc383ba050d">refine_polygonal_mesh</a> (const GEO::Mesh &amp;M_in, GEO::Mesh &amp;M_out, <a class="el" href="namespacepolyfem_1_1mesh_1_1_polygons.html#a3f1754102d92ff3ac4ee842b732dcc69">Polygons::SplitFunction</a> split_func)</td></tr>
<tr class="separator:acc2511254531ec745f412fc383ba050d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba258a79feeaaadcd741cd4fa889ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a1ba258a79feeaaadcd741cd4fa889ca9">refine_triangle_mesh</a> (const GEO::Mesh &amp;M_in, GEO::Mesh &amp;M_out)</td></tr>
<tr class="separator:a1ba258a79feeaaadcd741cd4fa889ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edb1ab6286b5c93e9f2a564ea072559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a9edb1ab6286b5c93e9f2a564ea072559">refine_polygonal_mesh</a> (const GEO::Mesh &amp;M_in, GEO::Mesh &amp;M_out, bool refine_polygons=false, double t=0.5)</td></tr>
<tr class="separator:a9edb1ab6286b5c93e9f2a564ea072559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb087429296c4e79bd346db0fce81ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aeb087429296c4e79bd346db0fce81ec5">singular_vertices</a> (const GEO::Mesh &amp;M, Eigen::VectorXi &amp;V, int regular_degree=4, bool ignore_border=true)</td></tr>
<tr class="separator:aeb087429296c4e79bd346db0fce81ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c1bdc69a7ad16cfa3eeb7d23b60867"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ad0c1bdc69a7ad16cfa3eeb7d23b60867">singular_edges</a> (const GEO::Mesh &amp;M, const Eigen::VectorXi &amp;V, Eigen::MatrixX2i &amp;E)</td></tr>
<tr class="separator:ad0c1bdc69a7ad16cfa3eeb7d23b60867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a20bc192a325efd376142bae8605c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a78a20bc192a325efd376142bae8605c0">singularity_graph</a> (const GEO::Mesh &amp;M, Eigen::VectorXi &amp;V, Eigen::MatrixX2i &amp;E, int regular_degree=4, bool ignore_border=true)</td></tr>
<tr class="separator:a78a20bc192a325efd376142bae8605c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2f88605218d9c84cb80764dd0887db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a6c2f88605218d9c84cb80764dd0887db">create_patch_around_singularities</a> (GEO::Mesh &amp;M, const Eigen::VectorXi &amp;V, const Eigen::MatrixX2i &amp;E, double t=0.5)</td></tr>
<tr class="separator:a6c2f88605218d9c84cb80764dd0887db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cc0f7013b784e8a488a1840e62d034"><td class="memItemLeft" align="right" valign="top">GEO::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a73cc0f7013b784e8a488a1840e62d034">mesh_vertex</a> (const GEO::Mesh &amp;M, GEO::index_t v)</td></tr>
<tr class="separator:a73cc0f7013b784e8a488a1840e62d034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f801017db21aa959f16cfc91c986a04"><td class="memItemLeft" align="right" valign="top">GEO::vec3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a9f801017db21aa959f16cfc91c986a04">facet_barycenter</a> (const GEO::Mesh &amp;M, GEO::index_t f)</td></tr>
<tr class="separator:a9f801017db21aa959f16cfc91c986a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7463d5f1886f0b3b79d678e7a6535801"><td class="memItemLeft" align="right" valign="top">GEO::index_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a7463d5f1886f0b3b79d678e7a6535801">mesh_create_vertex</a> (GEO::Mesh &amp;M, const GEO::vec3 &amp;p)</td></tr>
<tr class="separator:a7463d5f1886f0b3b79d678e7a6535801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2f4a1a50f2841a6eb95650ff7b1f0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#afe2f4a1a50f2841a6eb95650ff7b1f0e">compute_element_tags</a> (const GEO::Mesh &amp;M, std::vector&lt; <a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2">ElementType</a> &gt; &amp;element_tags)</td></tr>
<tr class="memdesc:afe2f4a1a50f2841a6eb95650ff7b1f0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the type of each facet in a surface mesh.  <a href="namespacepolyfem_1_1mesh.html#afe2f4a1a50f2841a6eb95650ff7b1f0e">More...</a><br /></td></tr>
<tr class="separator:afe2f4a1a50f2841a6eb95650ff7b1f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f115973d5927d123c20eb7941c5169e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a3f115973d5927d123c20eb7941c5169e">orient_normals_2d</a> (GEO::Mesh &amp;M)</td></tr>
<tr class="memdesc:a3f115973d5927d123c20eb7941c5169e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient facets of a 2D mesh so that each connected component has positive volume.  <a href="namespacepolyfem_1_1mesh.html#a3f115973d5927d123c20eb7941c5169e">More...</a><br /></td></tr>
<tr class="separator:a3f115973d5927d123c20eb7941c5169e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d707ded3f8dcf2686648b6d2c4aee3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a37d707ded3f8dcf2686648b6d2c4aee3">reorder_mesh</a> (Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, const Eigen::VectorXi &amp;C, Eigen::VectorXi &amp;R)</td></tr>
<tr class="memdesc:a37d707ded3f8dcf2686648b6d2c4aee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder vertices of a mesh using color tags, so that vertices are ordered by increasing colors.  <a href="namespacepolyfem_1_1mesh.html#a37d707ded3f8dcf2686648b6d2c4aee3">More...</a><br /></td></tr>
<tr class="separator:a37d707ded3f8dcf2686648b6d2c4aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a816bc73f845b5cd77603ab5804e15356"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a816bc73f845b5cd77603ab5804e15356">signed_squared_distances</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const Eigen::MatrixXd &amp;P, Eigen::VectorXd &amp;D)</td></tr>
<tr class="memdesc:a816bc73f845b5cd77603ab5804e15356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed squared distance from a list of points to a triangle mesh. This function build a AABB tree of the input mesh, computes the distance for each query point to the closest triangle, and then determines the sign by casting a vertical ray from the query point and counting the number of intersections with the input mesh.  <a href="namespacepolyfem_1_1mesh.html#a816bc73f845b5cd77603ab5804e15356">More...</a><br /></td></tr>
<tr class="separator:a816bc73f845b5cd77603ab5804e15356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da2ae1a2cf19143192bb198c5ebb5b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a7da2ae1a2cf19143192bb198c5ebb5b0">to_geogram_mesh</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, GEO::Mesh &amp;M)</td></tr>
<tr class="memdesc:a7da2ae1a2cf19143192bb198c5ebb5b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a triangle mesh to a Geogram mesh.  <a href="namespacepolyfem_1_1mesh.html#a7da2ae1a2cf19143192bb198c5ebb5b0">More...</a><br /></td></tr>
<tr class="separator:a7da2ae1a2cf19143192bb198c5ebb5b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa56d3e4087c89d5eec16b4af3f128879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aa56d3e4087c89d5eec16b4af3f128879">from_geogram_mesh</a> (const GEO::Mesh &amp;M, Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, Eigen::MatrixXi &amp;T)</td></tr>
<tr class="memdesc:aa56d3e4087c89d5eec16b4af3f128879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract simplices from a Geogram mesh.  <a href="namespacepolyfem_1_1mesh.html#aa56d3e4087c89d5eec16b4af3f128879">More...</a><br /></td></tr>
<tr class="separator:aa56d3e4087c89d5eec16b4af3f128879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad071b94c821ca0409fc672bd5c520bda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ad071b94c821ca0409fc672bd5c520bda">to_geogram_mesh</a> (const <a class="el" href="classpolyfem_1_1mesh_1_1_mesh3_d.html">Mesh3D</a> &amp;mesh, GEO::Mesh &amp;M)</td></tr>
<tr class="memdesc:ad071b94c821ca0409fc672bd5c520bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a hex mesh to a Geogram mesh.  <a href="namespacepolyfem_1_1mesh.html#ad071b94c821ca0409fc672bd5c520bda">More...</a><br /></td></tr>
<tr class="separator:ad071b94c821ca0409fc672bd5c520bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3366f41b53c326c7a196eea55d0c5c13"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a3366f41b53c326c7a196eea55d0c5c13">signed_volume</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F)</td></tr>
<tr class="memdesc:a3366f41b53c326c7a196eea55d0c5c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the signed volume of a surface mesh.  <a href="namespacepolyfem_1_1mesh.html#a3366f41b53c326c7a196eea55d0c5c13">More...</a><br /></td></tr>
<tr class="separator:a3366f41b53c326c7a196eea55d0c5c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f0a5489e7a8bc1a78e123094cb09854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a1f0a5489e7a8bc1a78e123094cb09854">orient_closed_surface</a> (const Eigen::MatrixXd &amp;V, Eigen::MatrixXi &amp;F, bool positive=true)</td></tr>
<tr class="memdesc:a1f0a5489e7a8bc1a78e123094cb09854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orient a triangulated surface to have positive volume.  <a href="namespacepolyfem_1_1mesh.html#a1f0a5489e7a8bc1a78e123094cb09854">More...</a><br /></td></tr>
<tr class="separator:a1f0a5489e7a8bc1a78e123094cb09854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c3a78516aa3e99cede8902c8eab4ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aa7c3a78516aa3e99cede8902c8eab4ca">extract_polyhedra</a> (const <a class="el" href="classpolyfem_1_1mesh_1_1_mesh3_d.html">Mesh3D</a> &amp;mesh, std::vector&lt; std::unique_ptr&lt; GEO::Mesh &gt;&gt; &amp;polys, bool triangulated=false)</td></tr>
<tr class="memdesc:aa7c3a78516aa3e99cede8902c8eab4ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract polyhedra from a 3D volumetric mesh.  <a href="namespacepolyfem_1_1mesh.html#aa7c3a78516aa3e99cede8902c8eab4ca">More...</a><br /></td></tr>
<tr class="separator:aa7c3a78516aa3e99cede8902c8eab4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae095321d3a795a54c96f6c93ed66583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aae095321d3a795a54c96f6c93ed66583">tertrahedralize_star_shaped_surface</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, const Eigen::RowVector3d &amp;kernel, Eigen::MatrixXd &amp;OV, Eigen::MatrixXi &amp;OF, Eigen::MatrixXi &amp;OT)</td></tr>
<tr class="memdesc:aae095321d3a795a54c96f6c93ed66583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tetrahedralize a star-shaped mesh, with a given point in its kernel.  <a href="namespacepolyfem_1_1mesh.html#aae095321d3a795a54c96f6c93ed66583">More...</a><br /></td></tr>
<tr class="separator:aae095321d3a795a54c96f6c93ed66583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103b61095d51f0f6fb355c436dfc6d5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a103b61095d51f0f6fb355c436dfc6d5d">sample_surface</a> (const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;F, int num_samples, Eigen::MatrixXd &amp;P, Eigen::MatrixXd *N=nullptr, int num_lloyd=10, int num_newton=10)</td></tr>
<tr class="memdesc:a103b61095d51f0f6fb355c436dfc6d5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Samples points on a surface.  <a href="namespacepolyfem_1_1mesh.html#a103b61095d51f0f6fb355c436dfc6d5d">More...</a><br /></td></tr>
<tr class="separator:a103b61095d51f0f6fb355c436dfc6d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4923ee604ddc3a313a19ef3344f0a719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a4923ee604ddc3a313a19ef3344f0a719">extract_parent_edges</a> (const Eigen::MatrixXd &amp;IV, const Eigen::MatrixXi &amp;IE, const Eigen::MatrixXd &amp;BV, const Eigen::MatrixXi &amp;BE, Eigen::MatrixXi &amp;OE)</td></tr>
<tr class="memdesc:a4923ee604ddc3a313a19ef3344f0a719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a set of edges that are overlap with a set given set of parent edges, using vertices positions to discriminate.  <a href="namespacepolyfem_1_1mesh.html#a4923ee604ddc3a313a19ef3344f0a719">More...</a><br /></td></tr>
<tr class="separator:a4923ee604ddc3a313a19ef3344f0a719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614178cdb624f2eff9500fabb9a4f432"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a614178cdb624f2eff9500fabb9a4f432">extract_triangle_surface_from_tets</a> (const Eigen::MatrixXd &amp;vertices, const Eigen::MatrixXi &amp;tets, Eigen::MatrixXd &amp;surface_vertices, Eigen::MatrixXi &amp;tris)</td></tr>
<tr class="memdesc:a614178cdb624f2eff9500fabb9a4f432"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract triangular surface from a tetmesh.  <a href="namespacepolyfem_1_1mesh.html#a614178cdb624f2eff9500fabb9a4f432">More...</a><br /></td></tr>
<tr class="separator:a614178cdb624f2eff9500fabb9a4f432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf27b815869b42b765af5c67692707a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#abf27b815869b42b765af5c67692707a1">save_edges</a> (const std::string &amp;filename, const Eigen::MatrixXd &amp;V, const Eigen::MatrixXi &amp;E)</td></tr>
<tr class="memdesc:abf27b815869b42b765af5c67692707a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save edge-graph into a .obj.  <a href="namespacepolyfem_1_1mesh.html#abf27b815869b42b765af5c67692707a1">More...</a><br /></td></tr>
<tr class="separator:abf27b815869b42b765af5c67692707a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1776e39bc78fd369d9c0b3a9a063c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#aad1776e39bc78fd369d9c0b3a9a063c3">read_fem_mesh</a> (const std::string &amp;mesh_path, Eigen::MatrixXd &amp;vertices, Eigen::MatrixXi &amp;cells, std::vector&lt; std::vector&lt; int &gt;&gt; &amp;elements, std::vector&lt; std::vector&lt; double &gt;&gt; &amp;weights, std::vector&lt; int &gt; &amp;body_ids)</td></tr>
<tr class="memdesc:aad1776e39bc78fd369d9c0b3a9a063c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a mesh  <a href="namespacepolyfem_1_1mesh.html#aad1776e39bc78fd369d9c0b3a9a063c3">More...</a><br /></td></tr>
<tr class="separator:aad1776e39bc78fd369d9c0b3a9a063c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cb1c08fb1f96a1f0c2bd635457e25f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ad5cb1c08fb1f96a1f0c2bd635457e25f">read_surface_mesh</a> (const std::string &amp;mesh_path, Eigen::MatrixXd &amp;vertices, Eigen::VectorXi &amp;codim_vertices, Eigen::MatrixXi &amp;codim_edges, Eigen::MatrixXi &amp;faces)</td></tr>
<tr class="memdesc:ad5cb1c08fb1f96a1f0c2bd635457e25f"><td class="mdescLeft">&#160;</td><td class="mdescRight">read a surface mesh  <a href="namespacepolyfem_1_1mesh.html#ad5cb1c08fb1f96a1f0c2bd635457e25f">More...</a><br /></td></tr>
<tr class="separator:ad5cb1c08fb1f96a1f0c2bd635457e25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb020dda8244f82ea9450b2d655cadd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#a0eb020dda8244f82ea9450b2d655cadd">is_planar</a> (const GEO::Mesh &amp;M, const double tol=1e-5)</td></tr>
<tr class="memdesc:a0eb020dda8244f82ea9450b2d655cadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the given mesh is planar (2D or tiny z-range).  <a href="namespacepolyfem_1_1mesh.html#a0eb020dda8244f82ea9450b2d655cadd">More...</a><br /></td></tr>
<tr class="separator:a0eb020dda8244f82ea9450b2d655cadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae919a9ea2b6d1a8776134338a06238a0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepolyfem_1_1mesh.html#ae919a9ea2b6d1a8776134338a06238a0">count_faces</a> (const int dim, const Eigen::MatrixXi &amp;cells)</td></tr>
<tr class="memdesc:ae919a9ea2b6d1a8776134338a06238a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of boundary elements (triangles for tetmesh and edges for triangle mesh)  <a href="namespacepolyfem_1_1mesh.html#ae919a9ea2b6d1a8776134338a06238a0">More...</a><br /></td></tr>
<tr class="separator:ae919a9ea2b6d1a8776134338a06238a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab40b3d90650fc21517c5a9af3e4cf960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40b3d90650fc21517c5a9af3e4cf960">&#9670;&nbsp;</a></span>EvalParametersFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(const Eigen::MatrixXd &amp;, Eigen::MatrixXd &amp;, int)&gt; <a class="el" href="namespacepolyfem_1_1mesh.html#ab40b3d90650fc21517c5a9af3e4cf960">polyfem::mesh::EvalParametersFunc</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a76cec2b541da1111313d4f148bfefbff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cec2b541da1111313d4f148bfefbff">&#9670;&nbsp;</a></span>GetAdjacentLocalEdge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;std::tuple&lt;int, int, bool&gt;int, int)&gt; <a class="el" href="namespacepolyfem_1_1mesh.html#a76cec2b541da1111313d4f148bfefbff">polyfem::mesh::GetAdjacentLocalEdge</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac25a28c10b676e06e484d9e1f496f826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25a28c10b676e06e484d9e1f496f826">&#9670;&nbsp;</a></span>BoundaryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepolyfem_1_1mesh.html#ac25a28c10b676e06e484d9e1f496f826">polyfem::mesh::BoundaryType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac25a28c10b676e06e484d9e1f496f826a9f4b55db1c20898d446a35bf7f99e856"></a>TriLine&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac25a28c10b676e06e484d9e1f496f826a8920b2d7b0827790538a324bc47631b4"></a>QuadLine&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1786d2b6b9b3bda8c6667456f9b1f5caab8c4c2cd6e0f11e2fbb894caeaeccef3"></a>Tri&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac25a28c10b676e06e484d9e1f496f826ae9017664588010860a92ceb5f8fcb824"></a>Quad&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac25a28c10b676e06e484d9e1f496f826a4c0a11247d92f73fb84baa51e37a3263"></a>Polygon&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac25a28c10b676e06e484d9e1f496f826a3d217ee3a015efcd968eff5f36a5f671"></a>Polyhedron&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac25a28c10b676e06e484d9e1f496f826a4bbb8f967da6d1a610596d7257179c2b"></a>Invalid&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a52d29c294eac8e3515c8c721ac4879c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d29c294eac8e3515c8c721ac4879c2">&#9670;&nbsp;</a></span>ElementType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2">polyfem::mesh::ElementType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2a02a335cb56996b16f7bece70be215789"></a>Simplex&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2ae38cb4ba5fe9ef406de581b29ed85dba"></a>RegularInteriorCube&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2a8b0ab3bbc7eff9a7f2cb5c2b55e5eeaf"></a>SimpleSingularInteriorCube&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2a5ce89c0d26dcc6af45bfe5002fcd3d64"></a>MultiSingularInteriorCube&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2a357bd1c8b060739c8fef502d46aed97f"></a>RegularBoundaryCube&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2abaf3184986c79f23f99cfc4faa826fc5"></a>SimpleSingularBoundaryCube&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2ac8474f7aab6df7b49f4bd4f2b92acdbb"></a>MultiSingularBoundaryCube&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2abc88e6a23d386795b4d2d0039bdd6f65"></a>InterfaceCube&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2a08324bb1398b4fd2d5ba3a6a37c3b7af"></a>InteriorPolytope&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2a80bef825f0fa4713f4bdc23033e25fe0"></a>BoundaryPolytope&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a52d29c294eac8e3515c8c721ac4879c2aec0fc0100c4fc1ce4eea230c3dc10360"></a>Undefined&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1786d2b6b9b3bda8c6667456f9b1f5ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1786d2b6b9b3bda8c6667456f9b1f5ca">&#9670;&nbsp;</a></span>MeshType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacepolyfem_1_1mesh.html#a1786d2b6b9b3bda8c6667456f9b1f5ca">polyfem::mesh::MeshType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1786d2b6b9b3bda8c6667456f9b1f5caa189920e88906221b0731b92bfb2ebcd7"></a>Tri&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1786d2b6b9b3bda8c6667456f9b1f5caab8c4c2cd6e0f11e2fbb894caeaeccef3"></a>Tri&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1786d2b6b9b3bda8c6667456f9b1f5caa11b8c9e9feec9bfa3206f5dffb736b9b"></a>Qua&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1786d2b6b9b3bda8c6667456f9b1f5caacc5883e092a3e5989ee2a1f05e6b2934"></a>HSur&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1786d2b6b9b3bda8c6667456f9b1f5caa77501a193048c70975005a2a1dfc15d1"></a>Tet&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1786d2b6b9b3bda8c6667456f9b1f5caaf232cbd41deb6ed29912b93b70a8aa30"></a>Hyb&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1786d2b6b9b3bda8c6667456f9b1f5caa77b3ac06c59fd2083e1ee4874c433832"></a>Hex&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="addb1327313435ccafb35bb476b034425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb1327313435ccafb35bb476b034425">&#9670;&nbsp;</a></span>append_selections() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::append_selections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>new_selections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpolyfem_1_1utils_1_1_selection.html#a8465d134d77a8f8dfeaffdde17950e54">polyfem::utils::Selection::BBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>start_element_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>end_element_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">polyfem::utils::Selection</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>selections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ac070fd8ba3c3767665b0cab25e5c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac070fd8ba3c3767665b0cab25e5c84">&#9670;&nbsp;</a></span>append_selections() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::append_selections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>new_selections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classpolyfem_1_1utils_1_1_selection.html#a8465d134d77a8f8dfeaffdde17950e54">Selection::BBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>start_element_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>end_element_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">Selection</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>selections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6d084b6f52a0af47a0f7b9d1e11fc33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d084b6f52a0af47a0f7b9d1e11fc33">&#9670;&nbsp;</a></span>apply_default_geometry_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::apply_default_geometry_parameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_prefix</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill in missing json geometry parameters with the default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry_in</td><td>input json geometry parameters </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">geometry_out</td><td>output json geometry parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d4be3bab49d477dc6c218108b278acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4be3bab49d477dc6c218108b278acc">&#9670;&nbsp;</a></span>clip_polygon_by_half_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::clip_polygon_by_half_plane </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVector2d &amp;&#160;</td>
          <td class="paramname"><em>q1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVector2d &amp;&#160;</td>
          <td class="paramname"><em>q2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clip a polygon by a half-plane. <a href="https://github.com/alicevision/geogram/blob/cfbc0a5827d71d59f8bcf0369cc1731ef12f82ef/src/examples/graphics/demo_Delaunay2d/main.cpp#L677">https://github.com/alicevision/geogram/blob/cfbc0a5827d71d59f8bcf0369cc1731ef12f82ef/src/examples/graphics/demo_Delaunay2d/main.cpp#L677</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>Input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q1</td><td>First endpoint of the clipping line </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q2</td><td>Second endpoint of the clipping line </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>Clipped polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe2f4a1a50f2841a6eb95650ff7b1f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2f4a1a50f2841a6eb95650ff7b1f0e">&#9670;&nbsp;</a></span>compute_element_tags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::compute_element_tags </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacepolyfem_1_1mesh.html#a52d29c294eac8e3515c8c721ac4879c2">ElementType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>element_tags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the type of each facet in a surface mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Input surface mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">element_tags</td><td>Types of each facet element </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa907e396724bca7b40434c67f80f2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa907e396724bca7b40434c67f80f2c9">&#9670;&nbsp;</a></span>compute_visibility_kernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::compute_visibility_kernel </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>OV</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the kernel of the given polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IV</td><td>#IV x (2|3) vertex positions around the input polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OV</td><td>#OV x (2|3) vertex positions around the output polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae919a9ea2b6d1a8776134338a06238a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae919a9ea2b6d1a8776134338a06238a0">&#9670;&nbsp;</a></span>count_faces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int polyfem::mesh::count_faces </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>cells</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of boundary elements (triangles for tetmesh and edges for triangle mesh) </p>

</div>
</div>
<a id="a6c2f88605218d9c84cb80764dd0887db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2f88605218d9c84cb80764dd0887db">&#9670;&nbsp;</a></span>create_patch_around_singularities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::create_patch_around_singularities </td>
          <td>(</td>
          <td class="paramtype">GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixX2i &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace612043f121e5ebe43de933f553396d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace612043f121e5ebe43de933f553396d">&#9670;&nbsp;</a></span>edge_adjacency_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::edge_adjacency_graph </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>edge_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt;&gt; *&#160;</td>
          <td class="paramname"><em>pairs_of_edges</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; int, int &gt;&gt; *&#160;</td>
          <td class="paramname"><em>pairs_of_quads</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi *&#160;</td>
          <td class="paramname"><em>quad_index</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4923ee604ddc3a313a19ef3344f0a719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4923ee604ddc3a313a19ef3344f0a719">&#9670;&nbsp;</a></span>extract_parent_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::extract_parent_edges </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>IE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>BV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>BE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>OE</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a set of edges that are overlap with a set given set of parent edges, using vertices positions to discriminate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IV</td><td>#IV x 3 input vertices positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IE</td><td>#IE x 2 input edge indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BV</td><td>#BV x 3 base vertices positions to test against </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">BE</td><td>#BE x 2 base edge indices to test against </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OE</td><td>#OE x 2 output extracted edges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7c3a78516aa3e99cede8902c8eab4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c3a78516aa3e99cede8902c8eab4ca">&#9670;&nbsp;</a></span>extract_polyhedra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::extract_polyhedra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpolyfem_1_1mesh_1_1_mesh3_d.html">Mesh3D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::unique_ptr&lt; GEO::Mesh &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>polys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>triangulated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract polyhedra from a 3D volumetric mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input volume mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">polys</td><td>Extracted polyhedral surfaces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a614178cdb624f2eff9500fabb9a4f432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614178cdb624f2eff9500fabb9a4f432">&#9670;&nbsp;</a></span>extract_triangle_surface_from_tets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::extract_triangle_surface_from_tets </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>tets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>surface_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>tris</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract triangular surface from a tetmesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">v,tets</td><td>tet mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s_v,tris</td><td>{ surface mesh } </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f801017db21aa959f16cfc91c986a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f801017db21aa959f16cfc91c986a04">&#9670;&nbsp;</a></span>facet_barycenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GEO::vec3 polyfem::mesh::facet_barycenter </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GEO::index_t&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c9e86a0cbb90821ce9b4c1f37b8df6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9e86a0cbb90821ce9b4c1f37b8df6c">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int polyfem::mesh::find </td>
          <td>(</td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa56d3e4087c89d5eec16b4af3f128879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa56d3e4087c89d5eec16b4af3f128879">&#9670;&nbsp;</a></span>from_geogram_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::from_geogram_mesh </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract simplices from a Geogram mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Input Geogram mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V x 3 output mesh vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">F</td><td>#F x 3 output mesh faces </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">T</td><td>#T x 4 output mesh tets </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa343729fa98cb887e320f61247db1843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa343729fa98cb887e320f61247db1843">&#9670;&nbsp;</a></span>instantiate_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool polyfem::mesh::instantiate_pattern </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>IF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>PV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>PF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>OV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>OF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi *&#160;</td>
          <td class="paramname"><em>SF</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepolyfem_1_1mesh.html#ab40b3d90650fc21517c5a9af3e4cf960">EvalParametersFunc</a>&#160;</td>
          <td class="paramname"><em>evalFunc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepolyfem_1_1mesh.html#a76cec2b541da1111313d4f148bfefbff">GetAdjacentLocalEdge</a>&#160;</td>
          <td class="paramname"><em>getAdjLocalEdge</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee0e69679f580e427e1db3922b2a5311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0e69679f580e427e1db3922b2a5311">&#9670;&nbsp;</a></span>is_inside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int polyfem::mesh::is_inside </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>inside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute whether points are inside a polygon</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IV</td><td>#IV x 2 of vertex positions for the input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Q</td><td>#Q x 2 of query point positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inside</td><td>Whether the i-th query point is inside or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of points inside </dd></dl>

</div>
</div>
<a id="a0eb020dda8244f82ea9450b2d655cadd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb020dda8244f82ea9450b2d655cadd">&#9670;&nbsp;</a></span>is_planar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool polyfem::mesh::is_planar </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tol</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the given mesh is planar (2D or tiny z-range). </p>

</div>
</div>
<a id="ae1e56322029f56281de64523a44a2b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e56322029f56281de64523a44a2b18">&#9670;&nbsp;</a></span>is_star_shaped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool polyfem::mesh::is_star_shaped </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::RowVector3d &amp;&#160;</td>
          <td class="paramname"><em>bary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine whether a polygon is star-shaped or not.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IV</td><td>#IV x (2|3) of vertex positions around the polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">bary</td><td>The barycenter of the kernel</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if star shaped, False otherwise. </dd></dl>

</div>
</div>
<a id="add37eb917dcfad1ce25e9f2aca7ca9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add37eb917dcfad1ce25e9f2aca7ca9db">&#9670;&nbsp;</a></span>line_weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double polyfem::mesh::line_weight </td>
          <td>(</td>
          <td class="paramtype">Eigen::Matrix&lt; double, 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23c11289ee171d378f95b975412b00d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23c11289ee171d378f95b975412b00d2">&#9670;&nbsp;</a></span>log_and_throw_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::log_and_throw_error </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7463d5f1886f0b3b79d678e7a6535801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7463d5f1886f0b3b79d678e7a6535801">&#9670;&nbsp;</a></span>mesh_create_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GEO::index_t polyfem::mesh::mesh_create_vertex </td>
          <td>(</td>
          <td class="paramtype">GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GEO::vec3 &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73cc0f7013b784e8a488a1840e62d034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cc0f7013b784e8a488a1840e62d034">&#9670;&nbsp;</a></span>mesh_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GEO::vec3 polyfem::mesh::mesh_vertex </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GEO::index_t&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve a 3D vector with the position of a given vertex. Contrary to geogram's version, this function works with both single and double precision meshes, as well as 2D meshes too.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M</td><td>Input mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">v</td><td><a class="el" href="structpolyfem_1_1mesh_1_1_vertex.html">Vertex</a> index whose position to retrieve</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Position of the given vertex in 3D </dd></dl>

</div>
</div>
<a id="a8ffb307ad1f47d970021d26cff0653d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffb307ad1f47d970021d26cff0653d7">&#9670;&nbsp;</a></span>offset_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::offset_polygon </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>OV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute offset polygon</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IV</td><td>#IV x 2 of vertex positions for the input polygon </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OV</td><td>#OV x 2 of vertex positions for the offset polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">eps</td><td>Offset distance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f0a5489e7a8bc1a78e123094cb09854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f0a5489e7a8bc1a78e123094cb09854">&#9670;&nbsp;</a></span>orient_closed_surface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::orient_closed_surface </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>positive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient a triangulated surface to have positive volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 3 input mesh vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x 3 input mesh facets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">positive</td><td>Orient for positive volume, or negative volume </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f115973d5927d123c20eb7941c5169e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f115973d5927d123c20eb7941c5169e">&#9670;&nbsp;</a></span>orient_normals_2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::orient_normals_2d </td>
          <td>(</td>
          <td class="paramtype">GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orient facets of a 2D mesh so that each connected component has positive volume. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">M</td><td>Surface mesh to reorient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0fd912c9c209068769d339932c8b7c79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd912c9c209068769d339932c8b7c79">&#9670;&nbsp;</a></span>read_fem_geometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::read_fem_geometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classpolyfem_1_1mesh_1_1_mesh.html">Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em> = <code>std::vector&lt;&#160;Eigen::MatrixXd&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em> = <code>std::vector&lt;&#160;Eigen::MatrixXi&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>non_conforming</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read FEM meshes from a geometry JSON array (or single) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>geometry JSON object(s) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_path</td><td>root path of JSON </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mesh</td><td>output <a class="el" href="classpolyfem_1_1mesh_1_1_mesh.html">Mesh</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab411f13e27498417ffaa63b50e0f3cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab411f13e27498417ffaa63b50e0f3cbe">&#9670;&nbsp;</a></span>read_fem_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::read_fem_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>jmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>in_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>in_cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>in_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>in_weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>num_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">Selection</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_selections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">Selection</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_selections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2f16fdc55deedd0a6cf9a4b4903dacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f16fdc55deedd0a6cf9a4b4903dacf">&#9670;&nbsp;</a></span>read_fem_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::read_fem_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>jmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>num_faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">polyfem::utils::Selection</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_selections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classpolyfem_1_1utils_1_1_selection.html">polyfem::utils::Selection</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>volume_selections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a FEM mesh from a geometry JSON </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jmesh</td><td>geometry JSON </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_path</td><td>root path of JSON </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>#V x 3/2 output vertices positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codim_vertices</td><td>indicies in vertices for the codimensional vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codim_edges</td><td>indicies in vertices for the codimensional edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faces</td><td>indicies in vertices for the surface faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad1776e39bc78fd369d9c0b3a9a063c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1776e39bc78fd369d9c0b3a9a063c3">&#9670;&nbsp;</a></span>read_fem_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool polyfem::mesh::read_fem_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>body_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_path</td><td>path to mesh file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">V</td><td>#V x 3/2 output vertices positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>#C cells (e.g., tri/tets/quad/hexes) </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">elements</td><td>#C indices for high-order nodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">w</td><td>#C weights for rational polynomials </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adc649d2ea30d21c08a016921d553ec90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc649d2ea30d21c08a016921d553ec90">&#9670;&nbsp;</a></span>read_obstacle_geometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::read_obstacle_geometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>displacements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classpolyfem_1_1mesh_1_1_obstacle.html">Obstacle</a> &amp;&#160;</td>
          <td class="paramname"><em>obstacle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em> = <code>std::vector&lt;&#160;std::string&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em> = <code>std::vector&lt;&#160;Eigen::MatrixXd&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Eigen::MatrixXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em> = <code>std::vector&lt;&#160;Eigen::MatrixXi&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>non_conforming</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a FEM mesh from a geometry JSON </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">geometry</td><td>geometry JSON object(s) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">displacements</td><td>displacements JSON object(s) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_path</td><td>root path of JSON </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">obstacle</td><td>output <a class="el" href="classpolyfem_1_1mesh_1_1_obstacle.html">Obstacle</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad2b062ad34fe687b7f1fb23a07e0696d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b062ad34fe687b7f1fb23a07e0696d">&#9670;&nbsp;</a></span>read_obstacle_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::read_obstacle_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>jmesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>root_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>codim_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>codim_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a obstacle mesh from a geometry JSON </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">jmesh</td><td>geometry JSON </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_path</td><td>root path of JSON </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>#V x 3/2 output vertices positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codim_vertices</td><td>indicies in vertices for the codimensional vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codim_edges</td><td>indicies in vertices for the codimensional edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faces</td><td>indicies in vertices for the surface faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5cb1c08fb1f96a1f0c2bd635457e25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cb1c08fb1f96a1f0c2bd635457e25f">&#9670;&nbsp;</a></span>read_surface_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool polyfem::mesh::read_surface_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>codim_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>codim_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>faces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read a surface mesh </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh_path</td><td>path to mesh file </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vertices</td><td>#V x 3/2 output vertices positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codim_vertices</td><td>indicies in vertices for the codimensional vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codim_edges</td><td>indicies in vertices for the codimensional edges </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">faces</td><td>indicies in vertices for the surface faces </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9edb1ab6286b5c93e9f2a564ea072559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edb1ab6286b5c93e9f2a564ea072559">&#9670;&nbsp;</a></span>refine_polygonal_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::refine_polygonal_mesh </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refine_polygons</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acc2511254531ec745f412fc383ba050d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc2511254531ec745f412fc383ba050d">&#9670;&nbsp;</a></span>refine_polygonal_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::refine_polygonal_mesh </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepolyfem_1_1mesh_1_1_polygons.html#a3f1754102d92ff3ac4ee842b732dcc69">Polygons::SplitFunction</a>&#160;</td>
          <td class="paramname"><em>split_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine a polygonal mesh. Quads and triangles are split into quads. If <code>refine_polygons</code> is set to <code>true</code>, then polygonal facets are also split into a layer of padding quads, and a new polygon is created around the barycenter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M_in</td><td>Surface mesh to subdivide </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M_out</td><td>Refined mesh </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">split_func</td><td>Functional used to split the new polygon interiors (boundary has already been split) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a98f8d68f49e3a96c2948a812d03521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a98f8d68f49e3a96c2948a812d03521">&#9670;&nbsp;</a></span>refine_quad_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::refine_quad_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>IF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>OV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>OF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ba258a79feeaaadcd741cd4fa889ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba258a79feeaaadcd741cd4fa889ca9">&#9670;&nbsp;</a></span>refine_triangle_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::refine_triangle_mesh </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refine a triangle mesh. Each input triangle is split into 4 new triangles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">M_in</td><td>Input surface mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M_out</td><td>Output surface mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d707ded3f8dcf2686648b6d2c4aee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d707ded3f8dcf2686648b6d2c4aee3">&#9670;&nbsp;</a></span>reorder_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::reorder_mesh </td>
          <td>(</td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>R</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reorder vertices of a mesh using color tags, so that vertices are ordered by increasing colors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">V</td><td>#V x d input mesh vertices </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">F</td><td>#F x k input mesh faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">C</td><td>#V per vertex color tag </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">R</td><td>max(C)+1 vector of starting indices for each colors (last value is the total number of vertices) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b53129ddbb617fbeb6b26d82171fd56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b53129ddbb617fbeb6b26d82171fd56">&#9670;&nbsp;</a></span>sample_polygon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::sample_polygon </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>IV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>S</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sample points on a polygon, evenly spaced from each other</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">IV</td><td>#IV x 2 vertex positions for the input polygon </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Desired number of samples </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">S</td><td>#S x 2 output sample positions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a103b61095d51f0f6fb355c436dfc6d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103b61095d51f0f6fb355c436dfc6d5d">&#9670;&nbsp;</a></span>sample_surface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::sample_surface </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_samples</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd *&#160;</td>
          <td class="paramname"><em>N</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_lloyd</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_newton</em> = <code>10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Samples points on a surface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 3 input mesh vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x 3 input mesh facets </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_samples</td><td>Number of desired samples </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">P</td><td>num_samples x 3 sample points positions </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">N</td><td>num_samples x 3 of normals estimated from the original surface (optional argument) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_lloyd</td><td>Number of Lloyd iterations </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_newton</td><td>Number of Newton iterations </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf27b815869b42b765af5c67692707a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf27b815869b42b765af5c67692707a1">&#9670;&nbsp;</a></span>save_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::save_edges </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save edge-graph into a .obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">filename</td><td>Filename to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 3 input vertices positions </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">E</td><td>#E x 2 input edge indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a816bc73f845b5cd77603ab5804e15356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a816bc73f845b5cd77603ab5804e15356">&#9670;&nbsp;</a></span>signed_squared_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::signed_squared_distances </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the signed squared distance from a list of points to a triangle mesh. This function build a AABB tree of the input mesh, computes the distance for each query point to the closest triangle, and then determines the sign by casting a vertical ray from the query point and counting the number of intersections with the input mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 3 input mesh vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x 3 input mesh faces </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">P</td><td>#P x 3 query points </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">D</td><td>#P x 1 computed signed distances, negative inside, positive outside </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3366f41b53c326c7a196eea55d0c5c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3366f41b53c326c7a196eea55d0c5c13">&#9670;&nbsp;</a></span>signed_volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double polyfem::mesh::signed_volume </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the signed volume of a surface mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 3 input mesh vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x 3 input mesh facets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Signed volume of the surface </dd></dl>

</div>
</div>
<a id="ad0c1bdc69a7ad16cfa3eeb7d23b60867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c1bdc69a7ad16cfa3eeb7d23b60867">&#9670;&nbsp;</a></span>singular_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::singular_edges </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixX2i &amp;&#160;</td>
          <td class="paramname"><em>E</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb087429296c4e79bd346db0fce81ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb087429296c4e79bd346db0fce81ec5">&#9670;&nbsp;</a></span>singular_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::singular_vertices </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regular_degree</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_border</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78a20bc192a325efd376142bae8605c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a20bc192a325efd376142bae8605c0">&#9670;&nbsp;</a></span>singularity_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::singularity_graph </td>
          <td>(</td>
          <td class="paramtype">const GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXi &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixX2i &amp;&#160;</td>
          <td class="paramname"><em>E</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>regular_degree</em> = <code>4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_border</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae095321d3a795a54c96f6c93ed66583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae095321d3a795a54c96f6c93ed66583">&#9670;&nbsp;</a></span>tertrahedralize_star_shaped_surface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::tertrahedralize_star_shaped_surface </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::RowVector3d &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>OV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>OF</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>OT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tetrahedralize a star-shaped mesh, with a given point in its kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 3 input mesh vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x 3 input mesh triangles </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kernel</td><td>A point in the kernel </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OV</td><td>#OV x 3 output mesh vertices </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OF</td><td>#OF x 3 output mesh surface triangles </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">OT</td><td>#OT x 4 output mesh tetrahedra </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7da2ae1a2cf19143192bb198c5ebb5b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da2ae1a2cf19143192bb198c5ebb5b0">&#9670;&nbsp;</a></span>to_geogram_mesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::to_geogram_mesh </td>
          <td>(</td>
          <td class="paramtype">const Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::MatrixXi &amp;&#160;</td>
          <td class="paramname"><em>F</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a triangle mesh to a Geogram mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">V</td><td>#V x 3 input mesh vertices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">F</td><td>#F x 3 input mesh surface </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>Output Geogram mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad071b94c821ca0409fc672bd5c520bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad071b94c821ca0409fc672bd5c520bda">&#9670;&nbsp;</a></span>to_geogram_mesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::to_geogram_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpolyfem_1_1mesh_1_1_mesh3_d.html">Mesh3D</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GEO::Mesh &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a hex mesh to a Geogram mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mesh</td><td>Input mesh </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td>Output Geogram mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6039e86ea6e80037d8fe94e72181ada2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6039e86ea6e80037d8fe94e72181ada2">&#9670;&nbsp;</a></span>transform_mesh_from_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void polyfem::mesh::transform_mesh_from_json </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacepolyfem.html#a77fa8fe96825827f2af726fcf6405d15">json</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::MatrixXd &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform a mesh inplace using json parameters including scaling, rotation, and translation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transform</td><td>json object with the mesh data </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">vertices</td><td>#V x 3/2 input and output vertices positions </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepolyfem.html">polyfem</a></li><li class="navelem"><a class="el" href="namespacepolyfem_1_1mesh.html">mesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
